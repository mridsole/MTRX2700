; ********************************************************************************
; MTRX2700 Lab 2
; Task 2 Part 1: "Timer System"
; GROUP: 7
; MEMBERS: Xinzan Guo, David Rapisarda, Thomas T. Cooper, Hughson Xu
; DESCRIPTION: Generates a PWM signal with a period of 71 ms and a duty cycle that
;               is controlled by the DIP switches. Uses output compare event
;               interrupts generated by the timer subsystem.
; MODIFIED: 10:00 13/04/2016
;               (added more detailed header information)
; ********************************************************************************

; export symbols
            XDEF                Entry, _Startup ; export 'Entry' symbol
            ABSENTRY            Entry           ; for absolute assembly: mark this as application entry point

; Include derivative-specific definitions 
		INCLUDE 'derivative.inc' 

;**************************************************************
;*                 Interrupt Vectors                          *
;**************************************************************
                ORG             $FFFE
                DC.W            Entry           ; Reset Vector
; ISR config - timer 4:
                ORG             $FFE6
                DC.W            isr_timer

ROMStart        EQU             $4000

; the PWM period, in cyles * 32 (after prescaling)
PERIOD          EQU             53250
                
; variable/data section
                ORG             RAMStart

; 0 = output signal is currently LOW
; 1 = output signal is currently HIGH
CYCLE_STATE     FCB             $01

; store the prescaled cycles we have to jump
; start with a square wave (so high time = low time)
CYCLES_HIGH     FDB             26625
CYCLES_LOW      FDB             26625

; code section
                ORG             ROMStart

Entry:
_Startup:
                LDS             #RAMEnd+1       ; initialize the stack pointer
                
; configure the timer system registers:
; (see lab book for the reasoning behind the values)
                SEI                             ; disable all interrupts

                MOVB            #$01,TCTL1      ; set up output to toggle
                MOVB            #$00,TCTL2      ; 
                MOVB            #$10,TIOS       ; select channel 4 for output compare
                MOVB            #$80,TSCR1      ; enable timers
                MOVB            #$05,TSCR2      ; prescaler div 32
                BSET            TIE,#$10        ; enable timer interrupt 4
                
                ; NOT SURE IF THIS IS NECESSARY - check on the actual board
                ;MOVB            #$FF,DDRT       ; configure port T as output

                ;BCLR            OC7M,#$FF

                CLI                             ; re-enable all interrupts
                
 ; configure DIP switches ports:
                MOVB            #$00,DDRH       ; configure DIP switches as inputs

; loop forever - keep polling the DIP switches for the duty cycle
mainLoop:
                LDAB            PTH             ; get data from DIP switches
                BSR             compute_duty_cycle  ; compute the duty cycle
                BRA             mainLoop        ; keep looping

; ******************************************************************************** 
; SUBROUTINE: compute_duty_cycle
; ARGS: B: the duty cycle, from 0-255
; computes the number of cycles to wait during the HIGH and the LOW parts of 
; the period (stores it in memory at CYCLES_HIGH and CYCLES_LOW)
; ********************************************************************************
compute_duty_cycle:
                PSHA                            ; push A to stack in case it's in use
                LDAA            #0              ; load 0 into A
                LDY             #PERIOD         ; load the period into Y
                EMUL                            ; extended multiply D and Y
                LDX             #255            ; load 255 into X
                EDIV                            ; extended divide Y:D by X
                STY             CYCLES_HIGH     ; store the HIGH result
                LDD             #PERIOD         ; load the period into D
                SUBD            CYCLES_HIGH     ; subtract the HIGH result to obtain LOW
                STD             CYCLES_LOW      ; store the LOW result
                PULA                            ; pull A back from the stack
                RTS                             ; return
                

; ******************************************************************************** 
; ISR: isr_timer
; ********************************************************************************
isr_timer:
                LDAA            CYCLE_STATE     ; load the state of the cycle into A
                CMPA            #$00            ; compare it with zero
                MOVB            #$10,TFLG1      ; clear the channel 4 timer flag
                BEQ             isr_timer_high  ; if 0, write high

                ; if the CYCLES_LOW is 0, then just return
                LDD             CYCLES_LOW      ; load CYCLES_LOW into D, so we can compare it
                CPD             #$00            ; perform the comparison
                BEQ             isr_timer_end   ; branch if CYCLES_LOW does equal 0

                ADDD            TCNT            ; otherwise, add CYCLES_LOW to TCNT
                STD             TC4             ; and write the result to TC4
                MOVB            #$00,PTT        ; write LOW to PTT
                MOVB            #$00,CYCLE_STATE  ; switch CYCLE_STATE from 1 to 0
                BRA             isr_timer_end   ; return

isr_timer_high:
                ; if CYCLES_HIGH is 0, return
                LDD             CYCLES_HIGH     ; load CYCLES_HIGH into D, so we can compare it
                CPD             #$00            ; perform the comparison with 0
                BEQ             isr_timer_end   ; if CYCLES_HIGH = 0, just return

                ADDD            TCNT            ; otherwise, add CYCLES_HIGH to TCNT
                STD             TC4             ; and write the result to TC4
                MOVB            #$10,PTT        ; write HIGH to pin 4 of PTT
                MOVB            #$01,CYCLE_STATE  ; switch CYCLE_STATE from 0 to 1
                BRA             isr_timer_end   ; return
                
isr_timer_end:
                RTI                             ; return
